связь прервалась, вот что ты уже сделал, продолжи с места обрыва

отлично! я разложил твой монолит на логичные модули, сохранив всю функциональность (пагинацию вверх, сортировку, аватары, контакты, фото/видео/аудио, реакции, кеш «хвоста» и дисковый кэш изображений, вьюер с догрузкой, FAB «вниз», запись голоса и т.д.).
Ниже — каждый файл по отдельности. Структура рассчитана на lib/ (Flutter default). Импортируй как есть, или подкорректируй пути под свой пакет.
lib/
  main.dart
  constants.dart
  api/
    api.dart
  models/
    models.dart
  utils/
    math_utils.dart
  cache/
    cache.dart
  playback/
    playback_hub.dart
  widgets/
    avatars.dart
    file_bubble.dart
    audio_voice_bubble.dart
    video_inline_preview.dart
    image_viewer.dart
    common_ui.dart
  screens/
    rooms_screen.dart
    contacts_screen.dart
    chat_screen.dart
    video_player_screen.dart
lib/constants.dart

lib/main.dart

lib/api/api.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:http/http.dart' as http;
import 'package:path/path.dart' as p;

import '../constants.dart';
import '../models/models.dart';

class NextcloudTalkApi {
  NextcloudTalkApi(this.username, this.appPassword);
  final String username;
  final String appPassword;

  Map<String, String> get _headers => {
        'OCS-APIRequest': 'true',
        'Accept': 'application/json',
        'Authorization': 'Basic ${base64Encode(utf8.encode('$username:$appPassword'))}',
      };

  Map<String, String> get authHeaders => {
        'Authorization': 'Basic ${base64Encode(utf8.encode('$username:$appPassword'))}',
      };

  Uri _u(String path, [Map<String, String>? q]) => Uri.parse(kNcBase + path).replace(queryParameters: q);

  String webdavFileUrl(String pathFromRoot) {
    final normalized = pathFromRoot.startsWith('/') ? pathFromRoot : '/$pathFromRoot';
    return '$kNcBase/remote.php/dav/files/$username$normalized';
    }

  String basicAuthInUrl(String url) {
    final uri = Uri.parse(url);
    final userInfo = '$username:$appPassword';
    return uri.replace(userInfo: userInfo).toString();
  }

  // ---- Rooms, participants, contacts ----

  Future<List<NcRoom>> listRooms({int limit = 100, bool includeStatus = false}) async {
    final url = _u('/ocs/v2.php/apps/spreed/api/v4/room', {
      'format': 'json',
      'limit': '$limit',
      if (includeStatus) 'includeStatus': '1',
    });
    final r = await http.get(url, headers: _headers);
    if (r.statusCode != 200) {
      throw Exception('listRooms HTTP ${r.statusCode}: ${r.body}');
    }
    final data = jsonDecode(r.body);
    final list = (data['ocs']?['data'] as List?) ?? const [];
    return list.map((e) => NcRoom.fromJson((e as Map).cast<String, dynamic>())).toList();
  }

  Future<List<NcParticipant>> listParticipants(String token, {bool includeStatus = false}) async {
    final url = _u('/ocs/v2.php/apps/spreed/api/v4/room/$token', {
      'format': 'json',
      if (includeStatus) 'includeStatus': '1',
    });
    final r = await http.get(url, headers: _headers);
    if (r.statusCode != 200) throw Exception('participants HTTP ${r.statusCode}: ${r.body}');
    final data = jsonDecode(r.body);
    final arr = (data['ocs']?['data']?['participants'] as List?) ?? const [];
    return arr.map((e) => NcParticipant.fromJson((e as Map).cast<String, dynamic>())).toList();
  }

  Future<NcRoom> createOrGetOneToOne(String userId) async {
    final url = _u('/ocs/v2.php/apps/spreed/api/v4/room', {'format': 'json'});
    final r = await http.post(
      url,
      headers: {..._headers, 'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8'},
      body: {'roomType': '1', 'invite': userId},
    );
    if (r.statusCode != 200 && r.statusCode != 201) {
      throw Exception('create 1:1 HTTP ${r.statusCode}: ${r.body}');
    }
    final data = jsonDecode(r.body);
    final j = (data['ocs']?['data'] as Map?)?.cast<String, dynamic>() ?? {};
    return NcRoom.fromJson(j);
  }

  // ---- Messaging (paged) ----

  Future<NcPage> fetchMessagesPaged(
    String token, {
    int lookIntoFuture = 1,
    int? lastKnownId,
    int limit = 100,
    int setReadMarker = 0,
    int markNotificationsAsRead = 0,
  }) async {
    final q = <String, String>{
      'format': 'json',
      'lookIntoFuture': '$lookIntoFuture',
      'limit': '$limit',
      'setReadMarker': '$setReadMarker',
      'markNotificationsAsRead': '$markNotificationsAsRead',
    };
    if (lastKnownId != null) q['lastKnownMessageId'] = '$lastKnownId';

    final url = _u('/ocs/v2.php/apps/spreed/api/v1/chat/$token', q);

    bool _isTransient(int code) => code == 502 || code == 503 || code == 504 || code == 408;

    Future<http.Response?> _tryOnce() async {
      try {
        return await http.get(url, headers: _headers).timeout(const Duration(seconds: 35));
      } on TimeoutException {
        return null; // помечаем как транзитный фейл
      }
    }

    // 1-я попытка
    http.Response? r = await _tryOnce();

    // При транзитном фейле сделаем бэкофф и повторим 1 раз
    if (r == null || _isTransient(r.statusCode)) {
      await Future.delayed(const Duration(milliseconds: 400));
      r = await _tryOnce();
    }

    if (r == null) {
      return NcPage(messages: const [], lastGiven: lastKnownId);
    }
    if (r.statusCode == 304) {
      return NcPage(messages: const [], lastGiven: lastKnownId);
    }
    if (_isTransient(r.statusCode)) {
      return NcPage(messages: const [], lastGiven: lastKnownId);
    }
    if (r.statusCode != 200) {
      final code = r.statusCode;
      final ct = (r.headers['content-type'] ?? '').toLowerCase();
      final brief = ct.contains('application/json') ? r.body : 'HTTP $code';
      throw Exception('fetchMessages HTTP $code: $brief');
    }

    final data = jsonDecode(r.body);
    final dataNode = data['ocs']?['data'];

    List<dynamic> raw = const [];
    if (dataNode is Map) {
      final m = dataNode['message'];
      if (m is List) raw = m; else if (m is Map) raw = (m as Map).values.toList();
    } else if (dataNode is List) {
      raw = dataNode;
    }

    final out = <NcMessage>[];
    for (final e in raw) {
      if (e is Map) out.add(NcMessage.fromJson((e as Map).cast<String, dynamic>()));
    }
    final lastGivenHeader = r.headers['x-chat-last-given'];
    final lastGiven = int.tryParse(lastGivenHeader ?? '') ?? lastKnownId;

    return NcPage(messages: out, lastGiven: lastGiven);
  }

  Future<void> sendMessage(String token, String message, {int? replyTo}) async {
    final url = _u('/ocs/v2.php/apps/spreed/api/v1/chat/$token', {'format': 'json'});
    final body = <String, String>{'message': message};
    if (replyTo != null) body['replyTo'] = '$replyTo';
    final r = await http.post(
      url,
      headers: {
        ..._headers,
        'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
      },
      body: body,
    );
    if (r.statusCode != 200 && r.statusCode != 201) {
      throw Exception('sendMessage HTTP ${r.statusCode}: ${r.body}');
    }
  }

  Future<void> sendFileToChat(
    String token,
    File file, {
    String? overrideName,
    int? replyTo,
    String? caption,
    String? messageType,
  }) async {
    final name = overrideName ?? p.basename(file.path);
    final remotePath = '/Talk/${DateTime.now().millisecondsSinceEpoch}_$name';
    await _webdavUpload(file, remotePath);
    await shareExistingFileToChat(
      token,
      remotePath,
      caption: caption,
      replyTo: replyTo,
      messageType: messageType,
    );
  }

  Future<void> _webdavUpload(File file, String remotePath) async {
    final url = webdavFileUrl(remotePath);
    final bytes = await file.readAsBytes();
    final r = await http.put(Uri.parse(url), headers: authHeaders, body: bytes);
    if (r.statusCode != 201 && r.statusCode != 200 && r.statusCode != 204) {
      throw Exception('WebDAV upload HTTP ${r.statusCode}: ${r.body}');
    }
  }

  Future<void> shareExistingFileToChat(
    String token,
    String remotePath, {
    String? caption,
    int? replyTo,
    String? messageType,
  }) async {
    final url = _u('/ocs/v2.php/apps/files_sharing/api/v1/shares', {'format': 'json'});
    final talkMeta = <String, dynamic>{};
    if (caption != null && caption.isNotEmpty) talkMeta['caption'] = caption;
    if (replyTo != null) talkMeta['replyTo'] = replyTo;
    if (messageType != null) talkMeta['messageType'] = messageType;

    final body = <String, String>{
      'shareType': '10',
      'shareWith': token,
      'path': remotePath,
    };
    if (talkMeta.isNotEmpty) {
      body['talkMetaData'] = jsonEncode(talkMeta);
    }

    final r = await http.post(
      url,
      headers: {
        ..._headers,
        'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
      },
      body: body,
    );
    if (r.statusCode != 200 && r.statusCode != 201) {
      throw Exception('shareToChat HTTP ${r.statusCode}: ${r.body}');
    }
  }

  Future<void> addReaction(String token, int messageId, String emoji) async {
    final url = _u('/ocs/v2.php/apps/spreed/api/v1/reaction/$token/$messageId', {'format': 'json'});
    final r = await http.post(
      url,
      headers: {
        ..._headers,
        'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
      },
      body: {'reaction': emoji},
    );
    if (r.statusCode != 200 && r.statusCode != 201) {
      throw Exception('addReaction HTTP ${r.statusCode}: ${r.body}');
    }
  }

  Future<void> deleteReaction(String token, int messageId, String emoji) async {
    final url = Uri.parse(kNcBase + '/ocs/v2.php/apps/spreed/api/v1/reaction/$token/$messageId?format=json');
    final req = http.Request('DELETE', url)
      ..headers.addAll({
        ..._headers,
        'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
      })
      ..bodyFields = {'reaction': emoji};
    final resp = await http.Client().send(req);
    final code = resp.statusCode;
    if (code != 200 && code != 201) {
      final body = await resp.stream.bytesToString();
      throw Exception('deleteReaction HTTP $code: $body');
    }
  }

  Future<void> editMessage(String token, int messageId, String newText) async {
    final url = _u('/ocs/v2.php/apps/spreed/api/v1/chat/$token/$messageId', {'format': 'json'});
    final r = await http.put(url,
        headers: {
          ..._headers,
          'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
        },
        body: {'message': newText});
    if (r.statusCode != 200 && r.statusCode != 202) {
      throw Exception('editMessage HTTP ${r.statusCode}: ${r.body}');
    }
  }

  Future<void> deleteMessage(String token, int messageId) async {
    final url = _u('/ocs/v2.php/apps/spreed/api/v1/chat/$token/$messageId', {'format': 'json'});
    final r = await http.delete(url, headers: _headers);
    if (r.statusCode != 200 && r.statusCode != 202) {
      throw Exception('deleteMessage HTTP ${r.statusCode}: ${r.body}');
    }
  }
}

class NcPage {
  NcPage({required this.messages, required this.lastGiven});
  final List<NcMessage> messages;
  final int? lastGiven;
}
lib/models/models.dart
import 'package:mime/mime.dart';

class NcRoom {
  NcRoom({
    required this.token,
    required this.displayName,
    this.lastMessage,
    this.type,
    this.lastActivity,
  });

  final String token;
  final String displayName;
  final String? lastMessage;
  final int? type;          // 1 = 1:1
  final int? lastActivity;  // unix sec

  factory NcRoom.fromJson(Map<String, dynamic> j) {
    String _s(dynamic v) => v?.toString() ?? '';
    int _i(dynamic v) {
      if (v is int) return v;
      if (v is String) return int.tryParse(v) ?? 0;
      if (v is double) return v.toInt();
      return 0;
    }

    final token = _s(j['token'] ?? j['roomToken']);
    final name  = _s(j['displayName'] ?? j['name']);
    String? last;
    try {
      last = (j['lastMessage']?['message']?['message'] ?? j['lastMessage']?['message'] ?? j['lastMessage'])?.toString();
    } catch (_) {}

    int? lastAct;
    try {
      final la = j['lastActivity'] ?? j['lastActivityTime'];
      lastAct = la == null ? null : _i(la);
    } catch (_) {}

    final t = j['type'] ?? j['roomType'];

    return NcRoom(
      token: token,
      displayName: name,
      lastMessage: (last?.isEmpty ?? true) ? null : last,
      type: t == null ? null : _i(t),
      lastActivity: lastAct,
    );
  }
}

class NcParticipant {
  NcParticipant({required this.actorType, this.actorId, this.displayName});
  final String actorType; // 'users'
  final String? actorId;
  final String? displayName;

  factory NcParticipant.fromJson(Map<String, dynamic> j) {
    return NcParticipant(
      actorType: (j['actorType'] ?? j['type'] ?? '').toString(),
      actorId: (j['actorId'] ?? j['id'] ?? '').toString(),
      displayName: (j['displayName'] ?? j['name'] ?? '').toString(),
    );
  }
}

class NcMessage {
  NcMessage({
    required this.id,
    this.actorId,
    this.actorDisplayName,
    this.message,
    required this.timestamp,
    this.isFile = false,
    this.filePath,
    this.fileId,
    this.fileMime,
    this.messageType,
    this.isSystemLike = false,
    this.parentId,
    this.parentAuthor,
    this.parentText,
    this.parentIsFile = false,
    this.parentFileName,
    this.reactions = const {},
    this.reactionsSelf = const [],
  });

  final int id;
  final String? actorId;
  final String? actorDisplayName;
  final String? message;
  final int timestamp;

  final bool isFile;
  final String? filePath;
  final int? fileId;
  final String? fileMime;

  final String? messageType;
  final bool isSystemLike;

  // Reply info
  final int? parentId;
  final String? parentAuthor;
  final String? parentText;
  final bool parentIsFile;
  final String? parentFileName;

  final Map<String, int> reactions;
  final List<String> reactionsSelf;

  factory NcMessage.fromJson(Map<String, dynamic> j) {
    int _toInt(dynamic v) {
      if (v is int) return v;
      if (v is String) return int.tryParse(v) ?? 0;
      if (v is double) return v.toInt();
      return 0;
    }

    String? _toString(dynamic v) => v?.toString();

    bool isFile = false;
    String? filePath;
    int? fileId;
    String? fileMime;

    bool systemish = false;

    try {
      final params = j['parameters'] ?? j['messageParameters'] ?? j['message_parameter'];
      if (params is Map) {
        final file = params['file'] ?? params['FILE'] ?? params['attachment'] ?? params['Attachment'];
        if (file is Map) {
          final rich = file['richObject'] ?? file['object'] ?? file;
          if (rich is Map) {
            filePath = _toString(rich['path'] ?? rich['link'] ?? rich['file'] ?? rich['name']);
            fileId = _toInt(rich['id']);
            fileMime = _toString(rich['mimetype'] ?? rich['mime'] ?? lookupMimeType(filePath ?? ''));
            isFile = filePath != null;
          }
        }
        if (params.containsKey('reaction') || params.containsKey('REACTION')) {
          systemish = true;
        }
      }
    } catch (_) {}

    final mtRaw = _toString(j['messageType'] ?? j['type'] ?? j['message_type']);
    final mt = mtRaw?.toLowerCase();
    if (mt != null) {
      if (mt.contains('system') ||
          mt.contains('reaction') ||
          mt.contains('activity') ||
          mt.contains('deleted') ||
          mt.contains('edit')) {
        systemish = true;
      }
    }
    final msgText = _toString(j['message'])?.toLowerCase() ?? '';
    if (msgText.contains('you edited') ||
        msgText.contains('вы изменили') ||
        msgText.contains('изменил') ||
        msgText.contains('удалил') ||
        msgText.contains('deleted') ||
        msgText.contains('reacted') ||
        msgText.contains('реакц')) {
      systemish = true;
    }

    // Parent info
    int? parentId;
    String? parentAuthor;
    String? parentText;
    bool parentIsFile = false;
    String? parentFileName;

    try {
      final parent = j['parent'];
      if (parent is Map) {
        parentId = _toInt(parent['id']);
        parentAuthor = _toString(parent['actorDisplayName'] ?? parent['actorId']);
        parentText = _toString(parent['message']);
        final pParams = parent['parameters'] ?? parent['messageParameters'];
        if (pParams is Map) {
          final f = pParams['file'] ?? pParams['attachment'];
          if (f is Map) {
            final rich = f['richObject'] ?? f['object'] ?? f;
            if (rich is Map) {
              parentFileName = _toString(rich['name'] ?? rich['path'] ?? rich['file']);
              parentIsFile = true;
            }
          }
        }
      }
    } catch (_) {}

    // Reactions
    Map<String, int> reactions = {};
    final rs = j['reactions'];
    if (rs is Map) {
      reactions = rs.map((k, v) => MapEntry(k.toString(), _toInt(v)));
    }
    List<String> reactionsSelf = [];
    final rself = j['reactionsSelf'];
    if (rself is List) {
      reactionsSelf = rself.map((e) => e.toString()).toList();
    }

    return NcMessage(
      id: _toInt(j['id']),
      actorId: _toString(j['actorId']),
      actorDisplayName: _toString(j['actorDisplayName']),
      message: _toString(j['message']),
      timestamp: _toInt(j['timestamp']),
      isFile: isFile,
      filePath: filePath,
      fileId: fileId,
      fileMime: fileMime,
      messageType: mtRaw,
      isSystemLike: systemish,
      parentId: parentId,
      parentAuthor: parentAuthor,
      parentText: parentText,
      parentIsFile: parentIsFile,
      parentFileName: parentFileName,
      reactions: reactions,
      reactionsSelf: reactionsSelf,
    );
  }

  Map<String, dynamic> toCacheJson() => {
        'id': id,
        'actorId': actorId,
        'actorDisplayName': actorDisplayName,
        'message': message,
        'timestamp': timestamp,
        'isFile': isFile,
        'filePath': filePath,
        'fileMime': fileMime,
        'messageType': messageType,
        'parentId': parentId,
        'parentAuthor': parentAuthor,
        'parentText': parentText,
        'parentIsFile': parentIsFile,
        'parentFileName': parentFileName,
        'reactions': reactions,
        'reactionsSelf': reactionsSelf,
      };

  factory NcMessage.fromCacheJson(Map<String, dynamic> j) => NcMessage(
        id: (j['id'] as num).toInt(),
        actorId: j['actorId'] as String?,
        actorDisplayName: j['actorDisplayName'] as String?,
        message: j['message'] as String?,
        timestamp: (j['timestamp'] as num).toInt(),
        isFile: (j['isFile'] as bool?) ?? false,
        filePath: j['filePath'] as String?,
        fileMime: j['fileMime'] as String?,
        messageType: j['messageType'] as String?,
        parentId: (j['parentId'] as num?)?.toInt(),
        parentAuthor: j['parentAuthor'] as String?,
        parentText: j['parentText'] as String?,
        parentIsFile: (j['parentIsFile'] as bool?) ?? false,
        parentFileName: j['parentFileName'] as String?,
        reactions: (j['reactions'] as Map?)?.map((k, v) => MapEntry(k.toString(), (v as num).toInt())) ?? const {},
        reactionsSelf: (j['reactionsSelf'] as List?)?.map((e) => e.toString()).toList() ?? const [],
      );
}
lib/utils/math_utils.dart
class MathUtils {
  static double sin(double x) => _sine(x);
  static double _sine(double x) {
    const pi = 3.1415926535897932;
    x = x % (2 * pi);
    final x2 = x * x;
    final x3 = x2 * x;
    final x5 = x3 * x2;
    final x7 = x5 * x2;
    final x9 = x7 * x2;
    return x - x3 / 6 + x5 / 120 - x7 / 5040 + x9 / 362880;
  }
}
lib/cache/cache.dart
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

import '../api/api.dart';
import '../models/models.dart';

class TalkCache {
  static const _maxKeep = 80;

  static Future<File> _file(String roomToken) async {
    final dir = await getApplicationDocumentsDirectory();
    return File(p.join(dir.path, 'talk_tail_$roomToken.json'));
  }

  static Future<void> saveTail(String roomToken, List<NcMessage> all) async {
    try {
      final visible = all.where((m) => !m.isSystemLike).toList();
      final tail = visible.length <= _maxKeep ? visible : visible.sublist(visible.length - _maxKeep);
      final file = await _file(roomToken);
      final jsonList = tail.map((m) => m.toCacheJson()).toList();
      await file.writeAsString(jsonEncode(jsonList));
    } catch (_) {}
  }

  /// Новый метод: сохраняет хвост + подкачивает изображения в дисковый кэш
  static Future<void> saveTailWithMedia(NextcloudTalkApi api, String roomToken, List<NcMessage> all) async {
    await saveTail(roomToken, all);

    try {
      final visible = all.where((m) => !m.isSystemLike).toList();
      final tail = visible.length <= _maxKeep ? visible : visible.sublist(visible.length - _maxKeep);

      final urls = <String>{};
      for (final m in tail) {
        if (m.isFile && (m.fileMime?.startsWith('image/') ?? false) && m.filePath != null) {
          urls.add(api.webdavFileUrl(m.filePath!));
        }
      }
      if (urls.isEmpty) return;

      const batch = 4;
      final list = urls.toList();
      for (int i = 0; i < list.length; i += batch) {
        final slice = list.sublist(i, i + batch > list.length ? list.length : i + batch);
        await Future.wait(slice.map((url) async {
          if (await ImageDiskCache.exists(url)) return;
          try {
            final r = await HttpClient().getUrl(Uri.parse(url))
              .then((req) {
                req.headers.add('Authorization', api.authHeaders['Authorization'] ?? '');
                return req.close();
              });
            if (r.statusCode == 200) {
              final bytes = await consolidateHttpClientResponseBytes(r);
              if (bytes.isNotEmpty) {
                await ImageDiskCache.put(url, bytes);
              }
            }
          } catch (_) {}
        }));
      }
    } catch (_) {}
  }

  static Future<List<NcMessage>?> loadTail(String roomToken) async {
    try {
      final file = await _file(roomToken);
      if (!await file.exists()) return null;
      final s = await file.readAsString();
      final arr = (jsonDecode(s) as List).cast<Map<String, dynamic>>();
      return arr.map((j) => NcMessage.fromCacheJson(j)).toList();
    } catch (_) {
      return null;
    }
  }
}

/// In-memory быстрый кеш
class MediaRamCache {
  static final _map = <String, Uint8List>{};
  static Uint8List? get(String k) => _map[k];
  static void set(String k, Uint8List v) { _map[k] = v; }
}

class ImageDiskCache {
  static const _subdir = 'img_cache';
  static const _maxCount = 150;

  static Future<Directory> _dir() async {
    final base = await getTemporaryDirectory();
    final d = Directory(p.join(base.path, _subdir));
    if (!await d.exists()) await d.create(recursive: true);
    return d;
  }

  static String _hash(String s) {
    int hash = 0;
    for (final codeUnit in s.codeUnits) {
      hash += codeUnit;
      hash += (hash << 10);
      hash ^= (hash >> 6);
    }
    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);
    final h = hash & 0xFFFFFFFF;
    return h.toRadixString(16).padLeft(8, '0');
  }

  static Future<File> _fileFor(String url) async {
    final d = await _dir();
    String ext = '.bin';
    try {
      final u = Uri.parse(url);
      final name = p.basename(u.path);
      final e = p.extension(name);
      if (e.length >= 2 && e.length <= 5) ext = e;
    } catch (_) {}
    final name = '${_hash(url)}$ext';
    return File(p.join(d.path, name));
  }

  static Future<bool> exists(String url) async {
    final f = await _fileFor(url);
    return f.exists();
  }

  static Future<Uint8List?> get(String url) async {
    try {
      final f = await _fileFor(url);
      if (await f.exists()) {
        return await f.readAsBytes();
      }
    } catch (_) {}
    return null;
  }

  static Future<void> put(String url, Uint8List bytes) async {
    try {
      final f = await _fileFor(url);
      await f.writeAsBytes(bytes, flush: false);
      await _evictIfNeeded();
    } catch (_) {}
  }

  static Future<void> _evictIfNeeded() async {
    try {
      final d = await _dir();
      final files = await d.list().where((e) => e is File).cast<File>().toList();

      if (files.length <= _maxCount) return;

      final stats = <File, DateTime>{};
      for (final f in files) {
        try {
          final s = await f.stat();
          stats[f] = s.modified;
        } catch (_) {}
      }
      final sorted = stats.entries.toList()..sort((a, b) => a.value.compareTo(b.value));
      final toDelete = sorted.take(sorted.length - _maxCount).map((e) => e.key);
      for (final f in toDelete) {
        try { await f.delete(); } catch (_) {}
      }
    } catch (_) {}
  }
}
lib/playback/playback_hub.dart
import 'package:just_audio/just_audio.dart';
import 'package:video_player/video_player.dart';

class PlaybackHub {
  static final _audioPlayers = <AudioPlayer>{};
  static final _videoCtrls = <VideoPlayerController>{};

  static void registerAudio(AudioPlayer p) => _audioPlayers.add(p);
  static void unregisterAudio(AudioPlayer p) => _audioPlayers.remove(p);

  static void registerVideo(VideoPlayerController c) => _videoCtrls.add(c);
  static void unregisterVideo(VideoPlayerController c) => _videoCtrls.remove(c);

  static Future<void> pauseAll() async {
    for (final p in _audioPlayers) {
      if (p.playing) {
        try { await p.pause(); } catch (_) {}
      }
    }
    for (final v in _videoCtrls) {
      try { await v.pause(); } catch (_) {}
    }
  }
}
lib/widgets/avatars.dart
import 'dart:convert';
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;

import '../api/api.dart';
import '../constants.dart';
import '../models/models.dart';

class NcAvatar {
  static Widget user({
    required NextcloudTalkApi api,
    required String userId,
    String? displayName,
    double radius = 20,
  }) {
    final safeId = Uri.encodeComponent(userId);
    final url = '${kNcBase}/index.php/avatar/$safeId/${(radius * 2).round()}';
    return _NcAvatar(
      url: url,
      headers: api.authHeaders,
      fallbackText: _initial(displayName ?? userId),
      radius: radius,
    );
  }

  static Widget conversation({
    required NextcloudTalkApi api,
    required String token,
    String? displayName,
    double radius = 20,
  }) {
    return _NcRoomAvatar(
      api: api,
      token: token,
      radius: radius,
      fallbackText: _initial(displayName ?? token),
    );
  }

  static String _initial(String s) {
    final t = s.trim();
    if (t.isEmpty) return '?';
    final rune = t.runes.first;
    return String.fromCharCode(rune).toUpperCase();
  }
}

class _NcRoomAvatar extends StatefulWidget {
  const _NcRoomAvatar({
    required this.api,
    required this.token,
    required this.radius,
    required this.fallbackText,
  });

  final NextcloudTalkApi api;
  final String token;
  final double radius;
  final String fallbackText;

  @override
  State<_NcRoomAvatar> createState() => _NcRoomAvatarState();
}

class _NcRoomAvatarState extends State<_NcRoomAvatar> {
  static final Map<String, Uint8List> _cache = {};
  Uint8List? _bytes;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final cacheKey = 'room:${widget.token}:${(widget.radius * 2).round()}';
    if (_cache.containsKey(cacheKey)) {
      setState(() => _bytes = _cache[cacheKey]);
      return;
    }
    try {
      final meta = await http.get(
        Uri.parse('${kNcBase}/ocs/v2.php/apps/spreed/api/v4/room/${widget.token}/avatar?format=json'),
        headers: {
          ...widget.api.authHeaders,
          'OCS-APIRequest': 'true',
          'Accept': 'application/json',
        },
      );
      if (meta.statusCode == 200) {
        final j = jsonDecode(meta.body);
        final rawUrl = (j['ocs']?['data']?['url'] ?? '').toString();
        if (rawUrl.isNotEmpty) {
          final fullUrl = rawUrl.startsWith('http')
              ? rawUrl
              : (rawUrl.startsWith('/') ? '$kNcBase$rawUrl' : '$kNcBase/$rawUrl');
          final img = await http.get(Uri.parse(fullUrl), headers: widget.api.authHeaders);
          if (img.statusCode == 200 && mounted) {
            _cache[cacheKey] = img.bodyBytes;
            setState(() => _bytes = img.bodyBytes);
            return;
          }
        }
      }
    } catch (_) {
      // игнор — fallback
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_bytes != null) {
      return CircleAvatar(radius: widget.radius, backgroundImage: MemoryImage(_bytes!));
    }
    return CircleAvatar(radius: widget.radius, child: Text(widget.fallbackText));
  }
}

class _NcAvatar extends StatefulWidget {
  const _NcAvatar({
    required this.url,
    required this.headers,
    required this.fallbackText,
    required this.radius,
  });

  final String url;
  final Map<String, String> headers;
  final String fallbackText;
  final double radius;

  @override
  State<_NcAvatar> createState() => _NcAvatarState();
}

class _NcAvatarState extends State<_NcAvatar> {
  static final Map<String, Uint8List> _cache = {};
  Uint8List? _bytes;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final key = '${widget.url}@${(widget.radius * 2).round()}';
    if (_cache.containsKey(key)) {
      setState(() => _bytes = _cache[key]);
      return;
    }
    try {
      final r = await http.get(Uri.parse(widget.url), headers: widget.headers);
      if (!mounted) return;
      if (r.statusCode == 200 && r.bodyBytes.isNotEmpty) {
        _cache[key] = r.bodyBytes;
        setState(() => _bytes = r.bodyBytes);
      }
    } catch (_) {}
  }

  @override
  Widget build(BuildContext context) {
    if (_bytes != null) {
      return CircleAvatar(radius: widget.radius, backgroundImage: MemoryImage(_bytes!));
    }
    return CircleAvatar(radius: widget.radius, child: Text(widget.fallbackText));
  }
}

class RoomAvatar extends StatefulWidget {
  const RoomAvatar({super.key, required this.api, required this.room, this.radius = 20});
  final NextcloudTalkApi api;
  final NcRoom room;
  final double radius;

  @override
  State<RoomAvatar> createState() => _RoomAvatarState();
}

class _RoomAvatarState extends State<RoomAvatar> {
  static final Map<String, String?> _peerCache = {}; // token -> other userId
  String? _peerId;
  String? _peerName;

  @override
  void initState() {
    super.initState();
    _resolvePeer();
  }

  Future<void> _resolvePeer() async {
    final cached = _peerCache[widget.room.token];
    if (cached != null) {
      _peerId = cached;
      setState(() {});
      return;
    }

    try {
      final parts = await widget.api.listParticipants(widget.room.token, includeStatus: false);
      final me = widget.api.username;

      String norm(String s) => s.toLowerCase();
      final candidates = parts.where((p) {
        final t = norm(p.actorType);
        final isUser = t == 'user' || t == 'users' || t == 'federated_users';
        return isUser && (p.actorId ?? '').isNotEmpty;
      }).toList();

      final other = candidates.firstWhere(
        (p) => (p.actorId ?? '') != me,
        orElse: () => NcParticipant(actorType: 'user', actorId: null, displayName: null),
      );

      if (!mounted) return;
      if (other.actorId != null) {
        _peerId = other.actorId;
        _peerName = other.displayName ?? other.actorId;
        _peerCache[widget.room.token] = _peerId;
        setState(() {});
        return;
      }
    } catch (_) {}

    // fallback по сообщениям:
    try {
      final page = await widget.api.fetchMessagesPaged(
        widget.room.token,
        lookIntoFuture: 0,
        lastKnownId: null,
        limit: 30,
        setReadMarker: 0,
        markNotificationsAsRead: 0,
      );
      final me = widget.api.username;
      final msgs = page.messages.reversed.toList();
      final otherMsg = msgs.firstWhere(
        (m) => (m.actorId ?? '').isNotEmpty && (m.actorId ?? '') != me,
        orElse: () => NcMessage(id: -1, timestamp: 0),
      );
      if (otherMsg.id != -1) {
        _peerId = otherMsg.actorId;
        _peerName = otherMsg.actorDisplayName ?? otherMsg.actorId;
        _peerCache[widget.room.token] = _peerId;
        if (mounted) setState(() {});
      }
    } catch (_) {}
  }

  @override
  Widget build(BuildContext context) {
    final name = widget.room.displayName.isEmpty ? widget.room.token : widget.room.displayName;

    if (_peerId != null && _peerId!.isNotEmpty) {
      return NcAvatar.user(
        api: widget.api,
        userId: _peerId!,
        displayName: _peerName ?? name,
        radius: widget.radius,
      );
    }

    return NcAvatar.conversation(
      api: widget.api,
      token: widget.room.token,
      displayName: name,
      radius: widget.radius,
    );
  }
}
lib/widgets/common_ui.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class SizeReporter extends StatefulWidget {
  const SizeReporter({super.key, required this.child, required this.onHeight});
  final Widget child;
  final void Function(double height) onHeight;

  @override
  State<SizeReporter> createState() => _SizeReporterState();
}

class _SizeReporterState extends State<SizeReporter> {
  final _key = GlobalKey();

  @override
  Widget build(BuildContext context) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final ctx = _key.currentContext;
      if (ctx != null) {
        final size = (ctx.findRenderObject() as RenderBox?)?.size;
        if (size != null) widget.onHeight(size.height);
      }
    });
    return Container(key: _key, child: widget.child);
  }
}

class RecordingBanner extends StatelessWidget {
  const RecordingBanner({
    super.key,
    required this.level,
    required this.onCancel,
    required this.onStopAndSend,
    this.error,
  });

  final double level;
  final VoidCallback onCancel;
  final VoidCallback onStopAndSend;
  final String? error;

  @override
  Widget build(BuildContext context) {
    final bg = Colors.red.withOpacity(0.08);
    final subtle = Theme.of(context).textTheme.bodyMedium;

    return Container(
      color: bg,
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
      child: SafeArea(
        top: false,
        bottom: false,
        child: LayoutBuilder(
          builder: (context, constraints) {
            final tight = constraints.maxWidth < 380;
            return Wrap(
              crossAxisAlignment: WrapCrossAlignment.center,
              spacing: 10,
              runSpacing: 6,
              children: [
                const Icon(Icons.mic, color: Colors.red),
                ConstrainedBox(
                  constraints: BoxConstraints(maxWidth: tight ? constraints.maxWidth * 0.35 : constraints.maxWidth * 0.45),
                  child: Text(
                    error == null ? 'Идёт запись…' : error!,
                    style: subtle?.copyWith(color: error == null ? null : Colors.red),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                _RecordingEq(level: level),
                TextButton(onPressed: onCancel, child: const Text('Отменить')),
                FilledButton.icon(
                  onPressed: onStopAndSend,
                  icon: const Icon(Icons.stop),
                  label: Text(tight ? 'Стоп' : 'Стоп и отправить'),
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}

class ReplyMini extends StatelessWidget {
  const ReplyMini({
    super.key,
    required this.author,
    required this.snippet,
    required this.isFile,
    required this.onTap,
  });

  final String author;
  final String snippet;
  final bool isFile;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).colorScheme.primary;
    final textStyle = Theme.of(context).textTheme.bodySmall!;
    return InkWell(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.only(bottom: 8),
        padding: const EdgeInsets.fromLTRB(10, 8, 10, 8),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.55),
          borderRadius: BorderRadius.circular(8),
          border: Border(left: BorderSide(color: color, width: 3)),
        ),
        child: Row(
          children: [
            Icon(isFile ? Icons.attach_file : Icons.reply, size: 16, color: color),
            const SizedBox(width: 8),
            Expanded(
              child: RichText(
                text: TextSpan(
                  style: textStyle,
                  children: [
                    TextSpan(text: author, style: textStyle.copyWith(fontWeight: FontWeight.w600, color: color)),
                    const TextSpan(text: '  '),
                    TextSpan(text: snippet, style: textStyle),
                  ],
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class ReplyBar extends StatelessWidget {
  const ReplyBar({
    super.key,
    required this.author,
    required this.snippet,
    required this.isFile,
    required this.onTap,
    required this.onClose,
  });

  final String author;
  final String snippet;
  final bool isFile;
  final VoidCallback onTap;
  final VoidCallback onClose;

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).colorScheme.primary;
    return Container(
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface.withOpacity(0.7),
        border: Border(left: BorderSide(color: color, width: 4)),
      ),
      padding: const EdgeInsets.fromLTRB(10, 8, 4, 8),
      child: Row(
        children: [
          Icon(isFile ? Icons.attach_file : Icons.reply, size: 18, color: color),
          const SizedBox(width: 8),
          Expanded(
            child: InkWell(
              onTap: onTap,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(author,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(color: color, fontWeight: FontWeight.w600)),
                  const SizedBox(height: 2),
                  Text(
                    snippet,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
              ),
            ),
          ),
          IconButton(icon: const Icon(Icons.close), onPressed: onClose)
        ],
      ),
    );
  }
}

class _RecordingEq extends StatelessWidget {
  const _RecordingEq({required this.level});
  final double level;

  @override
  Widget build(BuildContext context) {
    final bars = <double>[0.9, 0.7, 1.0, 0.7, 0.9].map((w) {
      final h = (6 + 22 * (level * w)).clamp(6, 28).toDouble();
      return h;
    }).toList();

    return SizedBox(
      height: 28,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          for (final h in bars)
            AnimatedContainer(
              duration: const Duration(milliseconds: 100),
              curve: Curves.easeOut,
              margin: const EdgeInsets.symmetric(horizontal: 2),
              width: 4,
              height: h,
              decoration: BoxDecoration(
                color: Colors.red,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
        ],
      ),
    );
  }
}
lib/widgets/audio_voice_bubble.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:just_audio/just_audio.dart';

import '../playback/playback_hub.dart';
import '../utils/math_utils.dart';

class AudioVoiceBubble extends StatefulWidget {
  const AudioVoiceBubble({super.key, required this.url, required this.headers});
  final String url;
  final Map<String, String> headers;

  @override
  State<AudioVoiceBubble> createState() => _AudioVoiceBubbleState();
}

class _AudioVoiceBubbleState extends State<AudioVoiceBubble> {
  late final AudioPlayer _player;
  StreamSubscription<Duration>? _posSub;
  StreamSubscription<PlayerState>? _stateSub;

  Duration _pos = Duration.zero;
  Duration _dur = Duration.zero;
  bool _ready = false;

  late final List<double> _wave;

  @override
  void initState() {
    super.initState();
    _player = AudioPlayer();
    PlaybackHub.registerAudio(_player);
    _init();
    _posSub = _player.positionStream.listen((d) {
      if (!mounted) return;
      setState(() => _pos = d);
    });
    _stateSub = _player.playerStateStream.listen((_) {
      if (!mounted) return;
      setState(() {});
    });

    _wave = _makeWave(widget.url);
  }

  @override
  void dispose() {
    PlaybackHub.unregisterAudio(_player);
    _posSub?.cancel();
    _stateSub?.cancel();
    _player.dispose();
    super.dispose();
  }

  List<double> _makeWave(String seed) {
    final n = 64;
    final out = List<double>.filled(n, 0.0);
    int s = seed.hashCode ^ 0x9e3779b9;
    double rnd() {
      s ^= (s << 13);
      s ^= (s >> 17);
      s ^= (s << 5);
      return ((s & 0x7fffffff) / 0x7fffffff);
    }

    for (int i = 0; i < n; i++) {
      final f1 = rnd();
      final f2 = rnd();
      final f3 = rnd();
      double v = 0.55 * f1 + 0.3 * f2 + 0.15 * f3;
      v += 0.12 * MathUtils.sin(i * 0.6) + 0.08 * MathUtils.sin(i * 0.18 + 1.7);
      out[i] = v;
    }
    for (int k = 0; k < 2; k++) {
      for (int i = 1; i < n - 1; i++) {
        out[i] = (out[i - 1] + out[i] * 2 + out[i + 1]) / 4.0;
      }
    }
    double minV = out.reduce((a, b) => a < b ? a : b);
    double maxV = out.reduce((a, b) => a > b ? a : b);
    final range = (maxV - minV).abs() < 1e-6 ? 1.0 : (maxV - minV);
    return out
        .map((v) => ((v - minV) / range))
        .map((v) => (0.15 + 0.85 * v).clamp(0.15, 1.0).toDouble())
        .toList();
  }

  Future<void> _init() async {
    try {
      await _player.setUrl(widget.url, headers: widget.headers);
      if (!mounted) return;
      setState(() {
        _ready = true;
        _dur = _player.duration ?? Duration.zero;
      });
    } catch (_) {}
  }

  void _toggle() async {
    if (!_ready) return;
    if (_player.playing) {
      await _player.pause();
    } else {
      await _player.play();
    }
    if (!mounted) return;
    setState(() {});
  }

  void _seekTo(double frac) {
    if (_dur.inMilliseconds == 0) return;
    final ms = (frac * _dur.inMilliseconds).clamp(0, _dur.inMilliseconds).toInt();
    _player.seek(Duration(milliseconds: ms));
  }

  @override
  Widget build(BuildContext context) {
    final playing = _player.playing;
    final frac = _dur.inMilliseconds == 0 ? 0.0 : _pos.inMilliseconds / _dur.inMilliseconds;

    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface.withOpacity(0.5),
        borderRadius: BorderRadius.circular(14),
      ),
      child: Row(
        children: [
          InkWell(
            onTap: _ready ? _toggle : null,
            customBorder: const CircleBorder(),
            child: Container(
              width: 44,
              height: 44,
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.primary,
                shape: BoxShape.circle,
              ),
              child: Icon(
                playing ? Icons.pause : Icons.play_arrow,
                color: Colors.white,
              ),
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            child: GestureDetector(
              behavior: HitTestBehavior.opaque,
              onTapDown: (d) {
                final box = d.localPosition.dx;
                final width = context.size?.width ?? 1;
                _seekTo(((box / width).clamp(0.0, 1.0)).toDouble());
              },
              child: CustomPaint(
                painter: _WavePainter(_wave, progress: frac, color: Theme.of(context).colorScheme.primary),
                size: const Size(double.infinity, 36),
              ),
            ),
          ),
          const SizedBox(width: 10),
          Text(
            _format(_pos),
            style: Theme.of(context).textTheme.labelMedium?.copyWith(
                  fontFeatures: const [FontFeature.tabularFigures()],
                ),
          ),
        ],
      ),
    );
  }

  String _format(Duration d) {
    final m = d.inMinutes.remainder(60).toString().padLeft(2, '0');
    final s = d.inSeconds.remainder(60).toString().padLeft(2, '0');
    final h = d.inHours;
    return h > 0 ? '$h:$m:$s' : '$m:$s';
  }
}

class _WavePainter extends CustomPainter {
  _WavePainter(this.values, {required this.progress, required this.color});
  final List<double> values;
  final double progress;
  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paintBg = Paint()
      ..color = Colors.grey.withOpacity(0.35)
      ..style = PaintingStyle.fill;
    final paintFg = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    final n = values.length;
    final barWidth = size.width / (n * 1.6);
    final gap = barWidth * 0.6;
    final baseline = size.height / 2;

    double x = 0;
    for (int i = 0; i < n; i++) {
      final h = values[i] * (size.height / 2);
      final rect = Rect.fromLTWH(x, baseline - h, barWidth, h * 2);
      canvas.drawRRect(RRect.fromRectAndRadius(rect, const Radius.circular(2)), paintBg);

      final filledTo = progress * size.width;
      if (x < filledTo) {
        final fillWidth = (filledTo - x).clamp(0, barWidth).toDouble();
        if (fillWidth > 0) {
          final r2 = Rect.fromLTWH(x, baseline - h, fillWidth, h * 2);
          canvas.drawRRect(RRect.fromRectAndRadius(r2, const Radius.circular(2)), paintFg);
        }
      }

      x += barWidth + gap;
    }
  }

  @override
  bool shouldRepaint(covariant _WavePainter oldDelegate) =>
      oldDelegate.values != values || oldDelegate.progress != progress || oldDelegate.color != color;
}
lib/widgets/video_inline_preview.dart
import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';

import '../playback/playback_hub.dart';

class VideoInlinePreview extends StatefulWidget {
  const VideoInlinePreview({super.key, required this.url, required this.headers, required this.onOpenFull});
  final String url;
  final Map<String, String> headers;
  final VoidCallback onOpenFull;

  @override
  State<VideoInlinePreview> createState() => _VideoInlinePreviewState();
}

class _VideoInlinePreviewState extends State<VideoInlinePreview> {
  VideoPlayerController? _ctrl;
  bool _ready = false;

  @override
  void initState() {
    super.initState();
    _ctrl = VideoPlayerController.networkUrl(Uri.parse(widget.url), httpHeaders: widget.headers)
      ..initialize().then((_) {
        if (!mounted) return;
        setState(() => _ready = true);
      });
    _ctrl?.setVolume(0);
    _ctrl?.pause();
    if (_ctrl != null) PlaybackHub.registerVideo(_ctrl!);
  }

  @override
  void dispose() {
    if (_ctrl != null) PlaybackHub.unregisterVideo(_ctrl!);
    _ctrl?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final ctrl = _ctrl;
    final double safeAR = ((ctrl?.value.aspectRatio ?? (16 / 9)).clamp(0.5, 3.0)).toDouble();

    return GestureDetector(
      onTap: widget.onOpenFull,
      child: AspectRatio(
        aspectRatio: safeAR,
        child: Stack(
          fit: StackFit.expand,
          children: [
            if (_ready && ctrl != null)
              VideoPlayer(ctrl)
            else
              Container(color: Colors.black12),
            const Align(
              alignment: Alignment.center,
              child: Icon(Icons.play_circle, size: 48, color: Colors.white70),
            ),
          ],
        ),
      ),
    );
  }
}
lib/widgets/file_bubble.dart
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:mime/mime.dart';
import 'package:path/path.dart' as p;
import 'package:url_launcher/url_launcher.dart';

import '../api/api.dart';
import '../cache/cache.dart';
import 'audio_voice_bubble.dart';
import 'video_inline_preview.dart';

class FileBubble extends StatefulWidget {
  const FileBubble({
    super.key,
    required this.api,
    required this.filePath,
    required this.mimeType,
    this.onOpenImage,
  });

  final NextcloudTalkApi api;
  final String filePath;
  final String mimeType;
  final VoidCallback? onOpenImage;

  @override
  State<FileBubble> createState() => _FileBubbleState();
}

class _FileBubbleState extends State<FileBubble> {
  Uint8List? _imageBytes;
  bool _loading = false;
  String? _error;
  late final String _webdavUrl;
  late final Map<String, String> _headers;

  @override
  void initState() {
    super.initState();
    _webdavUrl = widget.api.webdavFileUrl(widget.filePath);
    _headers = widget.api.authHeaders;
    if (widget.mimeType.startsWith('image/')) {
      _loadImage();
    }
  }

  Future<void> _loadImage() async {
    if (!mounted) return;
    setState(() {
      _loading = true;
      _error = null;
    });
    try {
      final cached = MediaRamCache.get(_webdavUrl);
      if (cached != null) {
        if (!mounted) return;
        setState(() => _imageBytes = cached);
      } else {
        final disk = await ImageDiskCache.get(_webdavUrl);
        if (disk != null) {
          MediaRamCache.set(_webdavUrl, disk);
          if (!mounted) return;
          setState(() => _imageBytes = disk);
        } else {
          final r = await http.get(Uri.parse(_webdavUrl), headers: _headers);
          if (!mounted) return;
          if (r.statusCode == 200) {
            MediaRamCache.set(_webdavUrl, r.bodyBytes);
            await ImageDiskCache.put(_webdavUrl, r.bodyBytes);
            setState(() => _imageBytes = r.bodyBytes);
          } else {
            setState(() => _error = 'HTTP ${r.statusCode}');
          }
        }
      }
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = e.toString());
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  void _openVideo() {
    // handled by chat screen with full-screen page; here we just call onOpenImage for images
  }

  @override
  Widget build(BuildContext context) {
    final isImg = widget.mimeType.startsWith('image/');
    final isAudio = widget.mimeType.startsWith('audio/');
    final isVideo = widget.mimeType.startsWith('video/');

    if (isImg) {
      if (_loading) return const SizedBox(height: 200, child: Center(child: CircularProgressIndicator()));
      if (_error != null) return Text('Ошибка превью: $_error');
      if (_imageBytes == null) return const Text('Нет превью');
      return GestureDetector(
        onTap: widget.onOpenImage ?? () {},
        child: ClipRRect(
          borderRadius: BorderRadius.circular(12),
          child: Image.memory(_imageBytes!, fit: BoxFit.cover),
        ),
      );
    }

    if (isAudio) {
      return AudioVoiceBubble(url: _webdavUrl, headers: _headers);
    }

    if (isVideo) {
      return VideoInlinePreview(
        url: _webdavUrl,
        headers: _headers,
        onOpenFull: _openVideo,
      );
    }

    final name = p.basename(widget.filePath);
    final mime = widget.mimeType.isNotEmpty ? widget.mimeType : (lookupMimeType(widget.filePath) ?? 'application/octet-stream');

    return ListTile(
      leading: const Icon(Icons.insert_drive_file_outlined),
      title: Text(name),
      subtitle: Text(mime),
      trailing: IconButton(
        icon: const Icon(Icons.open_in_new),
        onPressed: () async {
          final uri = widget.api.basicAuthInUrl(_webdavUrl);
          final ok = await launchUrl(Uri.parse(uri), mode: LaunchMode.externalApplication);
          if (!ok && mounted) {
            ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Не удалось открыть файл')));
          }
        },
      ),
    );
  }
}
lib/widgets/image_viewer.dart
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:http/http.dart' as http;

import '../api/api.dart';
import '../cache/cache.dart';

typedef LoadMoreBefore = Future<int> Function();

class ImageViewerPage extends StatefulWidget {
  const ImageViewerPage({
    super.key,
    required this.api,
    required this.roomToken,
    required this.items,
    required this.startIndex,
    required this.headers,
    required this.myReactions,
    required this.onReactionChanged,
    this.loadMoreBefore,
  });

  final NextcloudTalkApi api;
  final String roomToken;
  final List<ImageItem> items;
  final int startIndex;
  final Map<String, String> headers;

  final Map<int, String> myReactions;
  final void Function(int messageId, String? emojiOrNull) onReactionChanged;

  final LoadMoreBefore? loadMoreBefore;

  @override
  State<ImageViewerPage> createState() => _ImageViewerPageState();
}

class _ImageViewerPageState extends State<ImageViewerPage> with SingleTickerProviderStateMixin {
  late final PageController _pageCtrl;
  late int _index;

  final Map<String, Uint8List?> _bytes = {};

  final TransformationController _tc = TransformationController();
  bool _pagerLocked = false;

  late final AnimationController _dismissCtrl;
  double _dragOffsetX = 0.0;
  double _viewportWidth = 1.0;

  bool _uiVisible = true;
  bool _isPinching = false;

  late final ValueNotifier<int> _pageIndexVN = ValueNotifier<int>(0);

  static const _emojiChoices = [
    '👍','❤️','😂','😮','😢','🔥','👏','😍','😡','🎉','🤔','🤯','🙏','👌','😎','💯'
  ];

  @override
  void initState() {
    super.initState();
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
    _index = widget.startIndex.clamp(0, widget.items.length - 1).toInt();
    _pageCtrl = PageController(initialPage: _index);
    _pageIndexVN.value = _index;
    _preload(_index);
    _dismissCtrl = AnimationController(vsync: this, duration: const Duration(milliseconds: 220))
      ..addListener(() {
        setState(() {
          _dragOffsetX = _viewportWidth * _dismissCtrl.value;
        });
      });
  }

  @override
  void dispose() {
    _pageIndexVN.dispose();
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);
    _dismissCtrl.dispose();
    super.dispose();
  }

  Future<void> _preload(int i) async {
    if (i < 0 || i >= widget.items.length) return;
    final url = widget.items[i].url;
    if (_bytes.containsKey(url)) return;

    final cached = MediaRamCache.get(url);
    if (cached != null) {
      setState(() => _bytes[url] = cached);
      return;
    }

    final disk = await ImageDiskCache.get(url);
    if (disk != null) {
      MediaRamCache.set(url, disk);
      setState(() => _bytes[url] = disk);
      return;
    }

    try {
      final r = await http.get(Uri.parse(url), headers: widget.headers);
      if (!mounted) return;
      if (r.statusCode == 200) {
        MediaRamCache.set(url, r.bodyBytes);
        await ImageDiskCache.put(url, r.bodyBytes);
        setState(() => _bytes[url] = r.bodyBytes);
      } else {
        setState(() => _bytes[url] = null);
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('HTTP ${r.statusCode}')));
      }
    } catch (e) {
      if (!mounted) return;
      setState(() => _bytes[url] = null);
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Ошибка: $e')));
    }
  }

  void _onPageChanged(int i) async {
    setState(() => _index = i);
    _pageIndexVN.value = i;
    _tc.value = Matrix4.identity();
    _preload(i - 1);
    _preload(i + 1);

    if (i == 0 && widget.loadMoreBefore != null) {
      final before = widget.items.length;
      final added = await widget.loadMoreBefore!.call();
      if (!mounted) return;
      if (added > 0) {
        final now = widget.items.length;
        final delta = now - before;
        final newIndex = i + delta;
        _pageCtrl.jumpToPage(newIndex);
        _index = newIndex;
        _pageIndexVN.value = newIndex;
        setState(() {});
        _preload(newIndex - 1);
      }
    }
  }

  double _currentScale() => _tc.value.storage[0];

  void _onInteractionUpdate(ScaleUpdateDetails _) {
    final locked = _currentScale() > 1.01;
    if (locked != _pagerLocked) setState(() => _pagerLocked = locked);
  }

  void _onInteractionEnd(ScaleEndDetails _) {
    final locked = _currentScale() > 1.01;
    if (locked != _pagerLocked) setState(() => _pagerLocked = locked);
  }

  Future<void> _toggleReaction(String emoji) async {
    final msgId = widget.items[_index].messageId;
    final current = widget.myReactions[msgId];

    try {
      if (current == emoji) {
        await widget.api.deleteReaction(widget.roomToken, msgId, emoji);
        widget.myReactions.remove(msgId);
        widget.onReactionChanged(msgId, null);
      } else {
        if (current != null) {
          await widget.api.deleteReaction(widget.roomToken, msgId, current);
        }
        await widget.api.addReaction(widget.roomToken,